<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Vaporwave Audio Visualizer</title>
<style>
  html, body {
    margin: 0;
    height: 100%;
    background: #00ff00; /* Greenscreen background */
    overflow: hidden;
  }

  canvas {
    display: block;
    width: 100%;
    height: 100%;
  }
</style>
</head>
<body>
<canvas id="visualizer"></canvas>

<script>
const canvas = document.getElementById("visualizer");
const ctx = canvas.getContext("2d");

let analyser, dataArray;
let WIDTH, HEIGHT;

function resizeCanvas() {
  WIDTH = canvas.width = window.innerWidth;
  HEIGHT = canvas.height = window.innerHeight;
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

// Vaporwave colors for bars
const colors = [
  '#FF77FF', // pink/purple
  '#FFD700', // gold
  '#00FFFF', // cyan
  '#7F00FF', // violet
  '#FF6EC7', // neon pink
  '#00FFAA'  // mint green
];

// Automatically find Voicemeeter B2
async function getVoicemeeterStream() {
  const devices = await navigator.mediaDevices.enumerateDevices();
  const target = devices.find(d =>
    d.kind === "audioinput" && /voicemeeter/i.test(d.label)
  );

  if (!target) throw new Error("No Voicemeeter input device found. Make sure you granted mic/audio access in Chrome.");

  const constraints = { audio: { deviceId: { exact: target.deviceId } } };
  return await navigator.mediaDevices.getUserMedia(constraints);
}

async function setupAudio() {
  try {
    const stream = await getVoicemeeterStream();
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 256;
    const bufferLength = analyser.frequencyBinCount;
    dataArray = new Uint8Array(bufferLength);

    const source = audioCtx.createMediaStreamSource(stream);
    source.connect(analyser);

    draw();
  } catch (err) {
    alert("⚠️ Audio access failed: " + err.message);
  }
}

function draw() {
  requestAnimationFrame(draw);
  analyser.getByteFrequencyData(dataArray);
  ctx.clearRect(0, 0, WIDTH, HEIGHT);

  const barWidth = (WIDTH / dataArray.length) * 2.5;
  let x = 0;

  for (let i = 0; i < dataArray.length; i++) {
    const barHeight = (dataArray[i] / 255) * HEIGHT * 0.9;

    // Vaporwave color cycling
    const color = colors[i % colors.length];
    ctx.fillStyle = color;
    ctx.shadowBlur = 20;
    ctx.shadowColor = color;

    ctx.fillRect(x, HEIGHT - barHeight, barWidth, barHe
